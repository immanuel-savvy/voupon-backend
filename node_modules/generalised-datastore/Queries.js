"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _Event_handlers = _interopRequireDefault(require("./Event_handlers"));
var _functions = require("./utils/functions");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var Queries = /*#__PURE__*/function (_Event_listeners) {
  _inherits(Queries, _Event_listeners);
  var _super = _createSuper(Queries);
  function Queries() {
    var _this;
    _classCallCheck(this, Queries);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "write_to_ds", function (data_, options) {
      var filename,
        subfolder,
        no_joins,
        return_full,
        new_,
        exists,
        replace,
        data = (0, _functions.copy_object)(data_);
      if (options && _typeof(options) === "object") {
        subfolder = options.subfolder;
        no_joins = options.no_joins;
        return_full = options.return_full;
      }
      var filepath = "".concat(_this.folder_path, "/").concat(subfolder || "");
      if (data._id) {
        if (!(0, _functions.valid_id)(data._id) || data._id.split("~")[0] !== _this.folder_name) data._id = (0, _functions._id)(_this.folder_name);
      } else if (!data._id) data._id = (0, _functions._id)(_this.folder_name);else exists = !!_this.readone(data._id);
      if (!data.created) data.created = Date.now();
      if (!data.updated) data.updated = Date.now();
      var data_bfr_sweep = JSON.stringify(data);
      if (!exists || replace) {
        if (_this.config.subfolder) {
          if (!_this.config.recent_file || _this.config.recent_filesize >= _this.config.max_filesize) {
            filename = (0, _functions.get_timestamp_from_id)(data._id);
            _this.config.recent_file = filename;
            _this.config.recent_filesize = 0;
            new_ = true;
          } else filename = _this.config.recent_file;
        } else {
          filename = data._id;
          new_ = true;
        }
        if (!no_joins) data = _this.sweep_data(data);
        _this.write_file(filename, data, {
          new_: new_,
          subfolder: subfolder
        });
      }
      var result = {
        _id: data._id,
        filename: filename,
        exists: exists,
        replace: replace,
        filepath: filepath + filename,
        created: data.created,
        updated: data.updated
      };
      if (return_full) result.insertion = data_bfr_sweep === JSON.stringify(data) ? data : _this.readone(data._id, {
        subfolder: options && options.subfolder
      });
      return result;
    });
    _defineProperty(_assertThisInitialized(_this), "readfile", function (file_to_read) {
      var file;
      try {
        file = _this.fs.readFileSync(file_to_read, {
          encoding: "utf8"
        }) || null;
        file = _this.run_on_read_file(file, {
          filepath: file_to_read
        });
        if (file) {
          file = file.split("\n").filter(function (r) {
            return r;
          });
          for (var line = 0; line < file.length; line++) {
            try {
              file[line] = JSON.parse(file[line]);
            } catch (e) {
              throw new Error("JSON Parse Error in readfile ::: ".concat(file_to_read));
            }
          }
        } else file = new Array();
      } catch (e) {
        file = new Array();
      }
      return file;
    });
    _defineProperty(_assertThisInitialized(_this), "array_comparison", function (arr, comparison) {
      var find = false;
      for (var a = 0; a < arr.length; a++) {
        if (arr[a] === comparison) {
          find = true;
          break;
        }
      }
      return find;
    });
    _defineProperty(_assertThisInitialized(_this), "pass", function (line, query) {
      var or = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var pass = new Array();
      if (query === undefined) return true;
      for (var q in query) {
        var qval = query[q],
          lval = line[q];
        if (qval === undefined) continue;
        if (Array.isArray(lval) || Array.isArray(qval)) {
          var arr1 = void 0,
            arr2 = void 0;
          if (!Array.isArray(lval)) {
            arr1 = new Array(lval);
            arr2 = qval;
          } else if (!Array.isArray(qval)) {
            arr1 = new Array(qval);
            arr2 = lval;
          } else arr1 = qval, arr2 = lval;
          var m = false;
          for (var l = 0; l < arr1.length; l++) {
            if (_this.array_comparison(arr2, arr1[l])) {
              m = true;
              break;
            }
          }
          pass.push(m);
        } else if (_typeof(qval) === "object") {
          if (Object(qval).hasOwnProperty("$ne")) pass.push(lval !== qval["$ne"]);else if (Object(qval).hasOwnProperty("$e")) pass.push(lval === qval["$e"]);else if (Object(qval).hasOwnProperty("$gt")) pass.push(lval > qval["$gt"]);else if (Object(qval).hasOwnProperty("$lt")) pass.push(lval < qval["$lt"]);else if (Object(qval).hasOwnProperty("$gte")) pass.push(lval >= qval["$gte"]);else if (Object(qval).hasOwnProperty("$lte")) pass.push(lval <= qval["$lte"]);else if (Object(qval).hasOwnProperty("$includes")) pass.push(lval.includes && lval.includes(qval["$includes"]));else if (Object(qval).hasOwnProperty("$superquery") && typeof qval["$superquery"] === "function") pass.push(qval["$superquery"](line, lval, q));
        } else pass.push(lval === qval);
      }
      if (or) return !!pass.find(function (p) {
        return p;
      });else {
        for (var p = 0; p < pass.length; p++) {
          if (!pass[p]) return false;
        }
        return true;
      }
    });
    _defineProperty(_assertThisInitialized(_this), "search_file", function (query, file, or) {
      var match = new Array();
      for (var line_number = 0; line_number < file.length; line_number++) {
        var line = file[line_number];
        if (_this.pass(line, query, or)) match.push(line);
      }
      return match;
    });
    _defineProperty(_assertThisInitialized(_this), "iterative_read", function (lines) {
      var folders_et_ids = new Object(),
        lines_ids = new Array();
      lines.map(function (line) {
        for (var prop in line) {
          if (prop === "_id") {
            lines_ids.push(line[prop]);
            continue;
          }
          if (!_this.config.joins || _this.config.joins && !_this.config.joins.includes(prop)) continue;
          var value = line[prop];
          if (typeof value === "string" && (0, _functions.valid_id)(value)) {
            var folder = value.split("~")[0];
            var ids = folders_et_ids[folder];
            if (ids) ids.push(value);else folders_et_ids[folder] = new Array(value);
          }
        }
      });
      var folders_count = 0;
      for (var folder in folders_et_ids) {
        var folders_ids = folders_et_ids[folder];
        folders_et_ids[folder] = _this.ds.get_folder_by_id(folder).read(folders_ids, {
          limit: folders_ids.length,
          subfolder: lines_ids
        });
        folders_count++;
      }
      if (folders_count) lines = lines.map(function (line) {
        var _loop = function _loop(prop) {
          if (prop === "_id") return "continue";
          var value = line[prop];
          if (typeof value === "string" && (0, _functions.valid_id)(value)) {
            if (folders_et_ids[value.split("~")[0]]) line[prop] = folders_et_ids[value.split("~")[0]].find(function (file) {
              return file && file._id === value;
            }) || value;
          }
        };
        for (var prop in line) {
          var _ret = _loop(prop);
          if (_ret === "continue") continue;
        }
        return line;
      });
      return lines;
    });
    _defineProperty(_assertThisInitialized(_this), "search_ds", function (object, param) {
      for (var prop in object) {
        var value = object[prop];
        if (typeof value === "string") {
          value = value.toLowerCase().split(" ");
          for (var p = 0; p < param.length; p++) {
            for (var v = 0; v < value.length; v++) {
              if (value[v].includes(param[p])) return object;
            }
          }
        }
      }
    });
    _defineProperty(_assertThisInitialized(_this), "read_from_ds", function (query, options) {
      if (!options) options = new Object();
      var _options = options,
        limit = _options.limit,
        search_param = _options.search_param,
        or = _options.or,
        paging = _options.paging,
        exclude = _options.exclude,
        reverse = _options.reverse,
        skip = _options.skip,
        for_update = _options.for_update,
        reset_pager = _options.reset_pager,
        shuffle = _options.shuffle;
      var result = new Array(),
        update = new Array();
      if (exclude && typeof exclude === "string") exclude = new Array(exclude);else if (!Array.isArray(exclude)) exclude = null;
      if (paging) {
        if (_this.pages[paging] && _this.pages[paging].done && !reset_pager) return _this.search(search_param, result);else if (reset_pager && paging) delete _this.pages[paging];else if (_this.pages[paging]) exclude = _construct(Array, _toConsumableArray(_this.pages[paging].results).concat(_toConsumableArray(exclude || new Array())));
      }
      limit = limit || -1;
      if (!_this.config.subfolder && query && query._id) {
        if (!Array.isArray(query._id)) query._id = new Array(query._id);
        if (exclude) query._id = query._id.filter(function (_id) {
          return !exclude.includes(_id);
        });
        for (var i = 0; i < query._id.length; i++) {
          var _result;
          var __id = query._id[i];
          var file_to_read = "".concat(_this.folder_path, "/").concat(__id);
          var file = _this.readfile(file_to_read);
          if (for_update) {
            update.push({
              file_path: file_to_read,
              file: file,
              matches: file
            });
            if (for_update === 1) break;
            continue;
          }
          (_result = result).push.apply(_result, _toConsumableArray(file));
        }
      } else {
        if (!options.subfolder && query && _this.config.subfolder) {
          options.subfolder = new Array();
          _this.config.subfolder.map(function (subf) {
            return query[subf] && options.subfolder.push(query[subf]);
          });
        }
        var subfolders = options && options.subfolder ? Array.isArray(options.subfolder) ? options.subfolder : new Array(options.subfolder) : _this.read_subfolders();
        if (Number(skip) && skip > 0 && !_this.config.subfolder) {
          subfolders = subfolders.slice(skip);
        }
        for (var s = 0; s < subfolders.length; s++) {
          var subfolder = subfolders[s];
          var files = !_this.config.subfolder ? new Array(subfolder) : _this.read_subfolders(subfolder);
          if (reverse) files = files.sort(function (f1, f2) {
            return f2 - f1;
          });
          if (!_this.config.subfolder && exclude && exclude.includes(subfolder)) continue;
          var should_break = false;
          if (paging && _this.pages[paging]) files = files.slice(files.findIndex(function (file) {
            return file === _this.pages[paging].file_path.split("/").reverse()[0];
          }));
          for (var f = 0; f < files.length; f++) {
            var _result2;
            if (limit === 0) break;
            var file_path = "".concat(_this.folder_path, "/").concat(subfolder).concat(_this.config.subfolder ? "/".concat(files[f]) : "");
            var _file = _this.readfile(file_path);
            if (exclude && _this.config.subfolder) _file = _file.filter(function (line) {
              return !exclude.includes(line._id);
            });
            if (reverse) _file = _file.sort(function (f1, f2) {
              return f2.created - f1.created;
            });
            var matches = _this.search_file(query, _file, !!or);
            if (matches.length && for_update) {
              update.push({
                file_path: file_path,
                file: _file,
                matches: matches
              });
              if (for_update === 1) break;
              continue;
            }
            (_result2 = result).push.apply(_result2, _toConsumableArray(matches));
            result = result.sort(function (r1, r2) {
              return r2.created - r1.created;
            });
            if (Number(skip) > 0) {
              var result_len = result.length;
              result = result.slice(skip);
              skip -= result_len;
            }
            if (limit !== -1 && result.length >= limit || paging && !_this.pages[paging]) {
              if (result.length > limit) result = result.slice(0, limit);
              should_break = true;
              paging && _this.handle_paging(paging, result.map(function (line) {
                return line._id;
              }), file_path);
              break;
            }
          }
          if (should_break) break;
        }
        if (result.length < limit && _this.pages[paging] || !result.length && paging && _this.pages[paging]) _this.pages[paging].done = true;
      }
      return _this.search(search_param, for_update ? update : _this.shuffle(_this.iterative_read(result), shuffle));
    });
    _defineProperty(_assertThisInitialized(_this), "shuffle", function (array, should_shuffle) {
      should_shuffle && (0, _functions.shuffle_array)(array);
      return array;
    });
    _defineProperty(_assertThisInitialized(_this), "handle_paging", function (pager, results, file_path) {
      var page = _this.pages[pager];
      if (page) {
        var _page$results;
        (_page$results = page.results).push.apply(_page$results, _toConsumableArray(results));
        page.file_path = file_path;
      } else page = {
        results: results,
        file_path: file_path
      };
      _this.pages[pager] = page;
    });
    _defineProperty(_assertThisInitialized(_this), "read_subfolders", function (subfolder) {
      var files;
      try {
        files = _this.fs.readdirSync("".concat(_this.folder_path).concat(subfolder ? "/".concat(subfolder) : "")).filter(function (file) {
          return file !== ".config";
        });
      } catch (e) {}
      return files || new Array();
    });
    _defineProperty(_assertThisInitialized(_this), "write_file", function (filename, data, options) {
      if (!options) options = new Object();
      var _options2 = options,
        new_ = _options2.new_,
        subfolder = _options2.subfolder;
      var filepath = "".concat(_this.folder_path, "/").concat(_this.config.subfolder ? "".concat(subfolder, "/") + filename : filename);
      data = JSON.stringify(data);
      var previous_size = 0;
      if (_this.config.subfolder) {
        try {
          var bulk = _this.fs.readFileSync(filepath, {
            encoding: "utf8"
          }) || "";
          bulk = _this.run_on_read_file(bulk, {
            passive: true,
            filepath: filepath,
            options: options
          });
          if (bulk) previous_size = bulk.length;
          data = "".concat(bulk).concat(bulk ? "\n" : "").concat(data);
        } catch (e) {
          try {
            _this.fs.mkdirSync(filepath.split("/").slice(0, -1).join("/"));
          } catch (e) {}
        }
      }
      if (!filepath || filepath && !filepath.split) return;
      if (filepath.split("/").length <= 1) return;
      _this.fs.writeFileSync(filepath, _this.run_on_write_file(data, {
        filepath: filepath,
        options: options
      }), {
        encoding: "utf8"
      });
      if (new_) _this.config.total_files += 1;
      _this.config.total_size += data.length - previous_size;
      _this.config.total_entries += data.slice(previous_size ? previous_size + 1 : 0).split("\n").length;
      _this.config.updated = Date.now();
      _this.persist_config();
    });
    _defineProperty(_assertThisInitialized(_this), "update_file", function (filepath, file, options) {
      var data = "";
      file.forEach(function (line) {
        return data += "".concat(JSON.stringify(line), "\n");
      });
      filepath && filepath.split("/").length > 1 && _this.fs.writeFileSync(filepath, _this.run_on_write_file(data.trim(), {
        options: options,
        filepath: filepath
      }), {
        encoding: "utf8"
      });
    });
    _defineProperty(_assertThisInitialized(_this), "remove_file", function (filename, options) {
      if (!options) options = {};
      var _options3 = options,
        subfolder = _options3.subfolder,
        initial_size = _options3.initial_size,
        initial_length = _options3.initial_length;
      _this.fs.unlinkSync("".concat(_this.folder_path).concat(subfolder ? "/".concat(subfolder) : "", "/").concat(filename));
      _this.config.total_size -= initial_size || 0;
      _this.config.total_files -= 1;
      _this.config.total_entries -= initial_length || 0;
      _this.config.updated = Date.now();
      _this.persist_config();
    });
    _defineProperty(_assertThisInitialized(_this), "sweep_data", function (data_object) {
      if (_typeof(data_object) !== "object") return data_object;
      if (_typeof(data_object) === "object" && data_object && !Array.isArray(data_object)) {
        var _loop2 = function _loop2(prop) {
          var val = data_object[prop];
          if (Array.isArray(val)) {
            data_object[prop] = val.map(function (v) {
              return _this.sweep_data(v);
            });
          } else if (_typeof(val) === "object" && val) {
            if (val._id) {
              var folder = _this.ds.get_folder_by_id(val._id);
              if (folder) {
                var options_ = new Object(),
                  subfolder = new Array();
                if (folder.config.subfolder) {
                  folder.config.subfolder.map(function (sfolder) {
                    var v = val[sfolder];
                    if (typeof v === "string") subfolder.push(v);else if (_typeof(v) === "object" && (0, _functions.valid_id)(v._id)) subfolder.push(v._id);
                  });
                  subfolder = subfolder.filter(function (s) {
                    return s;
                  });
                  !subfolder.length && (subfolder.push(data_object._id), val[folder.config.subfolder[0]] = data_object._id);
                  options_.subfolder = subfolder;
                }
                folder.write(val, options_);
                data_object[prop] = val._id;
              }
            }
          }
        };
        for (var prop in data_object) {
          _loop2(prop);
        }
      }
      return data_object;
    });
    _defineProperty(_assertThisInitialized(_this), "update_in_ds", function (query, update_query, options) {
      var _ref = options || new Object(),
        several = _ref.several,
        subfolder = _ref.subfolder,
        updated = new Array();
      var result = _this[several ? "read" : "readone"](query, {
        subfolder: subfolder,
        for_update: several ? true : 1
      });
      if (result && result.length) {
        for (var r = 0; r < result.length; r++) {
          var _result$r = result[r],
            file = _result$r.file,
            file_path = _result$r.file_path,
            matches = _result$r.matches;
          var _loop3 = function _loop3(f) {
            var line = file[f];
            var limiter = 0;
            if (matches.find(function (match) {
              return match._id === line._id;
            })) {
              if (limiter && !several) return "break";
              _this.update_snips(line, update_query), updated.push(line);
              line.updated = Date.now();
              limiter++;
            }
            file[f] = line;
          };
          for (var f = 0; f < file.length; f++) {
            var _ret2 = _loop3(f);
            if (_ret2 === "break") break;
          }
          _this.update_file(file_path, file);
        }
      }
      return several ? updated : updated[0];
    });
    _defineProperty(_assertThisInitialized(_this), "update_snips", function (line, update_query) {
      var _loop4 = function _loop4(prop) {
        var update_value = update_query[prop];
        if (_typeof(update_value) === "object") {
          if (Object(update_value).hasOwnProperty("$inc")) {
            if (typeof line[prop] === "number" && typeof update_value["$inc"] === "number") line[prop] += update_value["$inc"];else if (typeof line[prop] !== "number" && typeof update_value["$inc"] === "number") line[prop] = update_value["$inc"];
          } else if (Object(update_value).hasOwnProperty("$dec")) {
            if (typeof line[prop] === "number" && typeof update_value["$dec"] === "number") line[prop] -= update_value["$dec"];else if (typeof line[prop] !== "number" && typeof update_value["$dec"] === "number") line[prop] = update_value["$dec"] * -1;
          } else if (Object(update_value).hasOwnProperty("$set")) {
            var value = update_value["$set"];
            if (!Array.isArray(value)) value = new Array(value);
            if (Array.isArray(line[prop])) value.map(function (val) {
              return !line[prop].includes(val) && line[prop].push(val);
            });else if (value.includes(line[prop])) line[prop] = _construct(Array, _toConsumableArray(value));else line[prop] = _construct(Array, [line[prop]].concat(_toConsumableArray(value)));
          } else if (Object(update_value).hasOwnProperty("$unshift") || Object(update_value).hasOwnProperty("$push")) {
            var _line$prop;
            var _value = update_value["$push"] || update_value["$unshift"];
            if (!Array.isArray(_value)) _value = new Array(_value);
            if (Array.isArray(line[prop])) (_line$prop = line[prop])[Object(update_value).hasOwnProperty("$push") ? "push" : "unshift"].apply(_line$prop, _toConsumableArray(_value));else {
              var init_line_prop = line[prop];
              line[prop] = _construct(Array, _toConsumableArray(_value));
              if (!init_line_prop) line[prop].unshift(init_line_prop);
            }
          } else if (Object(update_value).hasOwnProperty("$splice")) {
            var _value2 = update_value["$splice"],
              line_value = line[prop];
            if (!Array.isArray(_value2)) _value2 = new Array(_value2);
            if (Array.isArray(line_value)) {
              line[prop] = line_value.filter(function (val) {
                return !_value2.includes(val);
              });
            } else if (!Array.isArray(line_value) && line_value === _value2) delete line[prop];
          } else if (Object(update_value).hasOwnProperty("$superquery") && typeof update_value["$superquery"] === "function") {
            line[prop] = update_value["$superquery"](line, line[prop], prop);
          } else line[prop] = update_value;
        } else line[prop] = update_value;
      };
      for (var prop in update_query) {
        _loop4(prop);
      }
    });
    _defineProperty(_assertThisInitialized(_this), "remove_from_ds", function (query, options, several) {
      var total_remove = 0,
        removed = new Array();
      var _ref2 = options || new Object(),
        limit = _ref2.limit,
        exclude = _ref2.exclude,
        or = _ref2.or;
      if (exclude && typeof exclude === "string") exclude = new Array(exclude);
      if (!_this.config.subfolder && query && query._id) {
        if (!Array.isArray(query._id)) query._id = new Array(query._id);
        var filepath, file;
        for (var q = 0; q < query._id.length; q++) {
          var _id2 = query._id[q];
          filepath = "".concat(_this.folder_path, "/").concat(_id2);
          file = _this.readfile(filepath);
          _this.remove_file(_id2, {
            initial_length: 1,
            initial_size: JSON.stringify(file).length
          });
          removed.push(file);
        }
      } else {
        var subfolders = options && options.subfolder ? new Array(options.subfolder) : _this.read_subfolders();
        for (var s = 0; s < subfolders.length; s++) {
          var subfolder = subfolders[s];
          var files = !_this.config.subfolder ? new Array(subfolder) : _this.read_subfolders(subfolder);
          if (!_this.config.subfolder && exclude && exclude.includes(subfolder)) continue;
          var should_break = false;
          var _loop5 = function _loop5(f) {
            if (limit === 0) return "break";
            var filepath = "".concat(_this.folder_path, "/").concat(subfolder).concat(_this.config.subfolder ? "/".concat(files[f]) : "");
            var file = _this.readfile(filepath);
            if (exclude && _this.config.subfolder) file = file.filter(function (line) {
              return !exclude.includes(line._id);
            });
            var match = _this.search_file(query, file, or);
            if (!match.length) return "continue";
            var file_length = file.length;
            var filesize = JSON.stringify(file).length;
            if (!_this.config.subfolder) {
              removed.push(file[0]);
              _this.remove_file(subfolder, {
                initial_length: 1,
                initial_size: filesize
              });
              file = new Array();
            } else {
              file = file.map(function (line) {
                if (match.find(function (m) {
                  return m._id === line._id;
                })) removed.push(line);else return line;
              }).filter(function (f) {
                return f;
              });
              file.length ? _this.update_file(filepath, file) : _this.remove_file(files[f], {
                subfolder: subfolder,
                initial_length: file_length,
                initial_size: filesize
              });
              total_remove += file_length - file.length;
              if (limit !== -1 && total_remove >= limit) {
                removed = match;
                should_break = true;
                return "break";
              }
            }
          };
          for (var f = 0; f < files.length; f++) {
            var _ret3 = _loop5(f);
            if (_ret3 === "break") break;
            if (_ret3 === "continue") continue;
          }
          if (should_break) break;
        }
      }
      return several ? removed : removed[0];
    });
    return _this;
  }
  return _createClass(Queries);
}(_Event_handlers["default"]);
var _default = Queries;
exports["default"] = _default;
